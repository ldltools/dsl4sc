// e1; e2 -- e1 changes p to p or !p non-deterministically
//
// - then we turn out to obtain 2 traces (1) {p}e1{p}e2{p} and (2) {p}e1{!p}e2{p}
// - however, the dfa generated by mona merges the states for p and !p into one.
// - so, we need to annotate the conditions of the two rules for e2
//   with { x = 1 } and { x != 1 }
//
protocol e1; e2 ;;
variable p : prop; // p denotes whether x = 1 or not
rule
 on e1 do { if (env () == 1) x = 1; else x = 0; } ensure p | !p
 on e2 when p { x == 1 } do { console.log ("p holds"); } ensure p
 on e2 when !p { x != 1 } do { console.log ("p does not hold"); } ensure p { x = 1; }

script
{ <datamodel><data id="x"/><data id="env" expr="function () {return 1}"/></datamodel> }
