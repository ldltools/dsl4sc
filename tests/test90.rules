//protocol po;(ship1;invoice1;pay1 || ship2;invoice2;pay2) || cancel ;;
//protocol po;(ship1;ship2;invoice1;invoice2;pay1;pay2) || cancel ;;
protocol po; (cancel + ship1; (cancel + ship2; (cancel + invoice1; (cancel + invoice2; (cancel + pay1; (cancel + pay2)))))) ;;

/***
TODO: �}�N���őΉ�?
protocol
let PAYMENT1 = ship1;invoice1;pay1
    PAYMENT2 = ship2;invoice2;pay2
    CANEL = cancel*
in
    po;(PAYMENT1 || PAYMENT2) || CANCEL
***/

// invoice1�܂���invoice2���s��ꂽ��̓L�����Z���s��
property [{true}*;{invoiced1|invoiced2};{true}*] !cancelable;


rule
on po do !invoiced1 & !invoiced2 & cancelable {
  _data.items = _event.data.items;   // e.g.: [["Item1A","Item1B"],["Item2A","Item2B"]]
  _data.amount = _event.data.amount; // e.g.: [2000, 1000]
};

// TODO: ship(N),invoice(N),pay(N)���`���Ċȗ����ł��Ȃ����H�}�N���H
on ship1 when {
  _event.data.items.toString() == _data.items[0].toString()
} do { // empty};

on invoice1 when {
  _event.data.amount.toString() == _data.amount[0]
} do invoiced1 { _data.date[0] = _event.data.date };

on pay1 when {
  _event.data.amount == _data.amount[0] &amp;&amp;
  _event.data.date &lt; _data.date[0] + 30
} do { // empty };

on ship2 when {
  _event.data.items.toString() == _data.items[1].toString()
} do { // empty };

on invoice2 when {
  _event.data.amount.toString() == _data.amount[1]
} do invoiced2 { _data.date[1] = _event.data.date };

on pay2 when {
  _event.data.amount == _data.amount[1] &amp;&amp;
  _event.data.date &lt; _data.date[1] + 30
} do { // empty };

on cancel when cancelable do { // empty };
